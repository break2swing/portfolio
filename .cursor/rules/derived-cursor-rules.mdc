---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## <headers/>

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

This section covers guidelines for project documentation, especially regarding the `CLAUDE.md` and `AGENTS.md` files.

### Updating `CLAUDE.md` and `AGENTS.md`

The `CLAUDE.md` and `AGENTS.md` files must be kept up-to-date to reflect the current state of the codebase. The update process involves:

1.  **Reading Existing Files:** Always start by reading the current versions of `@CLAUDE.md` and `@AGENTS.md`.
2.  **Project Analysis:** Analyze the project structure, configuration, key components, contexts, services, and library configurations. Key files to inspect include:
    *   `package.json`
    *   `tsconfig.json`
    *   `next.config.js`
    *   `tailwind.config.ts`
    *   `app/layout.tsx`
    *   `app/*/page.tsx`
    *   `components/AppLayout.tsx`
    *   `contexts/*.tsx`
    *   `services/*.tsx`
    *   `components/Sidebar.tsx`
    *   `components/Topbar.tsx`
    *   `lib/*.ts`
3.  **Change Identification:** Compare the current project state with the documentation in `CLAUDE.md` and `AGENTS.md` to identify discrepancies. Look for:
    *   New contexts or services.
    *   New routes or pages.
    *   New important dependencies.
    *   Changes in architecture.
    *   New patterns or conventions.
    *   Modifications in provider structure.
4.  **`CLAUDE.md` Content:**
    *   **Must Include:**
        *   Project overview.
        *   Development commands.
        *   High-level architecture (requiring the reading of multiple files).
        *   Route structure.
        *   Layout system.
        *   Theme and context systems.
        *   Backend integration (e.g., Supabase).
        *   Component library.
        *   Development patterns.
    *   **Must Not Include:**
        *   Obvious instructions.
        *   Generic development practices.
        *   Easily discoverable information.
5.  **`AGENTS.md` Content:**
    *   **Must Include:**
        *   Naming conventions.
        *   File structure (templates).
        *   Import order.
        *   Patterns to follow (Client vs Server, state management, error handling).
        *   Specific workflows (adding pages, service, component).
        *   Styling guidelines.
        *   Project-specific points of attention.
        *   Language conventions.
    *   **Template Format:** Always provide concrete code examples showing the expected file structure.
6.  **Validation:** Ensure consistency between the two files, up-to-date information, correct code examples, accurate file paths, and a provider hierarchy in `app/layout.tsx` that matches the actual code. Also ensure new services/contexts are documented.
7. **Process:**
    * List the identified changes as bullet points.
    * Update `CLAUDE.md` with the necessary modifications.
    * Update `AGENTS.md` with the necessary modifications.
    * Summarize the changes made in each file.
8. **Important Instructions:**
    * Be exhaustive in the analysis.
    * Verify ALL contexts in `contexts/`.
    * Verify ALL services in `services/`.
    * List all current routes.
    * Verify the actual structure of providers in `app/layout.tsx`.
    * Maintain the existing format and structure of the files.
    * Do not invent information - always check the code source.

## TECH STACK

*   `@tanstack/react-virtual`
*   `lucide-react`
*   `@dnd-kit/core`
*   `@dnd-kit/sortable`
*   `@dnd-kit/utilities`
*   `react-markdown`
*   `react-syntax-highlighter` + `@types/react-syntax-highlighter` or `shiki` (for syntax highlighting)
*   `octokit` (optional) - Client GitHub API if full GitHub integration is needed

## WORKFLOW & RELEASE RULES

*   When creating a pull request, analyze recent file changes to understand the modifications.
*   Utilize tools like `read_file`, `codebase_search`, and `grep` to identify changes.
*   Search for specific keywords or patterns related to the changes (e.g., "admin/(photos|music|videos|texts)" in `components/Sidebar.tsx`).
*   Search for "CHANGELOG" to track changes.
*   Based on the analysis, generate a detailed pull request description including:
    *   A summary of the changes.
    *   A list of the main changes.
    *   The files modified.
    *   Technical details.
    *   A checklist of tests performed.
    *   Screenshots (if applicable).
    *   Links to related issues.
    *   The type of change (e.g., feature).
    *   The impact of the change.
    *   Whether there are any breaking changes.
* When implementing new features that require database changes, such as adding a tagging system, the pull request description must include:
    * Database schema changes, including new tables, columns, and relationships.
    * RLS (Row Level Security) configurations for new tables.
    * Migration scripts (SQL) to apply the database changes.
    * Suggested default tags for the new feature, where applicable.
* When creating a pull request for a unified tagging system, the description should include:
    * A summary of the addition of a unified tagging system for classifying and organizing content (photos, videos, music, texts).
    * Details about the shared tags across all media types and the centralized management interface.
    * Information about the database schema:
        * `tags` table with name, slug (auto-generated), and customizable color.
        * Many-to-many relationship tables: `photo_tags`, `video_tags`, `music_tags`, and `text_tags`.
        * Indexes for optimized search queries.
        * CASCADE constraints for automatic relationship deletion.
    * Backend services details:
        * `tagService.ts`: CRUD operations for tags and management of relationships with texts.
        * `photoTagService.ts`, `videoTagService.ts`, `musicTagService.ts`: management of tag relationships for photos, videos, and music respectively.
        * `createPhotoWithTags`, `createVideoWithTags`, `createTrackWithTags` methods in respective services.
        * `getAllPhotosWithTags`, `getAllVideosWithTags`, `getAllTracksWithTags` methods for retrieving media with their tags.
    * Admin interface details:
        * `TagManager`: interface for tag management (creation, modification, deletion, color selection, Zod validation, grid display with colored badges).
        * Integration in admin pages: `/admin/photos`, `/admin/videos`, `/admin/music`, and `/admin/texts`.
    * UI components details:
        * `TagBadge`: reusable component for displaying tags with `default`, `outline`, and `secondary` variants, customizable colors, and click/delete support.
        * Integration in upload forms: `PhotoUploadForm`, `VideoUploadForm`, `MusicUploadForm`, and `TextUploadForm`.
    * Public display details:
        * Tags displayed on content cards (photos, videos, texts) with colored badges and consistent styling supporting light/dark themes.
    * Lists of new and modified files.
    * TypeScript types, including `Tag`, `PhotoWithTags`, `VideoWithTags`, and `MusicTrackWithTags`.
    * Migration details, including the creation of relationship tables with primary key constraints, foreign key constraints with CASCADE, indexes, and documentation comments.
    * Recommended tests (create, modify, delete tags; upload media with tags; upload media with tags; verify tag display on public pages; verify color consistency in light/dark mode).
    * Technical notes (shared tags, auto-generated slugs, hexadecimal color storage, automatic cascading deletion, error management with `{ data, error }` pattern, and Zod validation).
*   **CI/CD with GitHub Actions:**
    *   Set up CI/CD workflows using GitHub Actions for automated linting, type checking, building, and deployment.
    *   Create `.github/workflows/ci.yml` for continuous integration:
        ```yaml
        name: CI

        on:
          push:
            branches: [ main, develop ]
          pull_request:
            branches: [ main, develop ]

        jobs:
          lint-and-typecheck:
            name: Lint & Type Check
            runs-on: ubuntu-latest

            steps:
              - name: Checkout code
                uses: actions/checkout@v4

              - name: Setup Node.js
                uses: actions/setup-node@v4
                with:
                  node-version: '20'
                  cache: 'npm'

              - name: Install dependencies
                run: npm ci

              - name: Run ESLint
                run: npm run lint

              - name: Run TypeScript type check
                run: npm run type check

          build:
            name: Build
            runs-on: ubuntu-latest
            needs: lint-and-typecheck

            steps:
              - name: Checkout code
                uses: actions/checkout@v4

              - name: Setup Node.js
                uses: actions/setup-node@v4
                with:
                  node-version: '20'
                  cache: 'npm'

              - name: Install dependencies
                run: npm ci

              - name: Build project
                run: npm run build
                env:
                  # Variables nécessaires pour le build (même si vides, pour éviter les erreurs)
                  NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL || '' }}
                  NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY || '' }}

              - name: Upload build artifacts
                uses: actions/upload-artifact@v4
                with:
                  name: build-output
                  path: out/
                  retention-days: 7
        ```
    *   Create `.github/workflows/deploy.yml` for automated deployment (optional):
        ```yaml
        name: Deploy

        on:
          push:
            branches: [ main ]

        jobs:
          deploy:
            name: Deploy to Production
            runs-on: ubuntu-latest
            if: github.ref == 'refs/heads/main'

            steps:
              - name: Checkout code
                uses: actions/checkout@v4

              - name: Setup Node.js
                uses: actions/setup-node@v4
                with:
                  node-version: '20'
                  cache: 'npm'

              - name: Install dependencies
                run: npm ci

              - name: Build project
                run: npm run build
                env:
                  NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
                  NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}

              # Option 1: Déploiement sur GitHub Pages
              - name: Deploy to GitHub Pages
                uses: peaceiris/actions-gh-pages@v3
                if: github.ref == 'refs/heads/main'
                with:
                  github_token: ${{ secrets.GITHUB_TOKEN }}
                  publish_dir: ./out

              # Option 2: Déploiement sur Vercel (décommentez si vous utilisez Vercel)
              # - name: Deploy to Vercel
              #   uses: amondnet/vercel-action@v25
              #   with:
              #     vercel-token: ${{ secrets.VERCEL_TOKEN }}
              #     vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
              #     vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
              #     vercel-args: '--prod'
        ```
    *   Configure GitHub secrets in the repository settings (Settings → Secrets and variables → Actions):
        *   `NEXT_PUBLIC_SUPABASE_URL`: Supabase URL.
        *   `NEXT_PUBLIC_SUPABASE_ANON_KEY`: Supabase anonymous key.
        *   (Optional) `GITHUB_TOKEN`: Automatically generated.
        *   (Optional) `VERCEL_TOKEN`, `VERCEL_ORG_ID`, `VERCEL_PROJECT_ID`: If using Vercel.
    *   If the main branch is named `master` instead of `main`, update the `.yml` files accordingly.
*   When discussing an idea with AI and asking for a PRD:
    *   For simple projects, use the `example_prd.txt` template.
    *   For complex systems, use the `example_prd_rpg.txt` template (for dependency-aware task graphs). Save the PRD to `.taskmaster/docs/prd.txt`.
    *   After the PRD is created, parse it to generate initial tasks using: `task-master parse-prd .taskmaster/docs/prd.txt`. Then, analyze the complexity of these tasks with `task-master analyze-complexity --research` and expand the tasks into sub-tasks with `task-master expand --all --research`. Finally, see the next task to do with `task-master next`.
*   When aiming to improve performance, start by analyzing existing plans and tasks related to performance optimization.
*   When creating a pull request for implementing a social share feature, the description should include:
    * A summary of the addition of social share capabilities to enable users to share content on various platforms.
    * Details about the implementation of the `lib/shareUtils.ts` and `components/ShareButton.tsx` files.
    * Information about the integrated platforms:
        * Twitter
        * Facebook
        * LinkedIn
        * WhatsApp
        * Telegram
        * Reddit
        * Pinterest
        * Email
    * UI components details:
        * `ShareButton`: reusable component for displaying share options using `DropdownMenu` from `shadcn/ui`.
    * Public display details:
        * Share buttons are integrated into `PhotoViewerModal`, `TextDetailModal`, and `AudioPlayer` components.
    * Lists of new and modified files.
    * Details about how the URLs are generated and encoded for each platform using `generateShareUrl` function.
    * Details about UTM parameters used for tracking analytics.
    * Recommended tests (verify share URLs, opening in new windows, UTM parameters, image sharing on Pinterest, mobile compatibility, linting, and SSR compatibility).
    * Technical notes (SVG icons, static export compatibility, security measures).
* When creating a pull request for implementing a set of additional share services:
    * A summary of the addition of WhatsApp, Telegram, Reddit and Pinterest share capabilities to enable users to share content on various platforms.
    * Details about the implementation of the `lib/shareUtils.ts` and `components/ShareButton.tsx` files.
    * Information about the integrated platforms:
        * WhatsApp
        * Telegram
        * Reddit
        * Pinterest
    * UI components details:
        * `ShareButton`: reusable component for displaying share options using `DropdownMenu` from `shadcn/ui`.
    * Public display details:
        * Share buttons are integrated into `PhotoViewerModal`, `TextDetailModal`, and `AudioPlayer` components.
    * Lists of new and modified files.
    * Details about how the URLs are generated and encoded for each platform using `generateShareUrl` function.
    * Details about UTM parameters used for tracking analytics.
    * Recommended tests (verify share URLs, opening in new windows, UTM parameters, mobile compatibility, linting).
* When creating a pull request to enhance the audio player and playlist functionalities, the description should include:
    * A summary of the improvements to the audio player, including the addition of personalized playlists, the ability to share playlist items, and drag-and-drop functionality for playlist reorganization.
    * Details about the database schema changes, including:
        * The addition of a `playlists` table with columns for `id`, `name`, `description`, `user_id`, `is_public`, `display_order`, `created_at`, and `updated_at`.
        * The addition of a `playlist_tracks` table with columns for `id`, `playlist_id`, `track_id`, `display_order`, and `added_at`, and a unique constraint on `playlist_id` and `track_id`.
        * Indexes on `playlist_tracks.playlist_id`, `playlist_tracks.track_id`, and `playlist_tracks.display_order` for optimized query performance.
        * Row Level Security (RLS) policies enabled for both tables, restricting access and modifications based on ownership and public visibility.
    * Backend services details, including the creation of a `playlistService.ts` with methods for:
        * Creating playlists (`createPlaylist`).
        * Retrieving user playlists (`getUserPlaylists`).
        * Retrieving playlist tracks (`getPlaylistTracks`).
        * Adding tracks to playlists (`addTrackToPlaylist`).
        * Removing tracks from playlists (`removeTrackFromPlaylist`).
        * Updating the order of tracks in a playlist (`updatePlaylistOrder`).
        * Updating playlist metadata (`updatePlaylist`).
        * Deleting playlists (`deletePlaylist`).
        * Retrieving a playlist with its associated tracks (`getPlaylistWithTracks`).
    * Admin interface details, including:
        * The creation of a `PlaylistManager.tsx` component for displaying and managing playlists.
        * A "Create playlist" button opening a `CreatePlaylistDialog`.
    * UI components details, including:
        * The creation of a `CreatePlaylistDialog.tsx` component with a form for creating new playlists, including Zod validation.
    * Public display details, including:
        * The integration of a "My Playlists" tab in `app/musique/page.tsx`.
        * The display of the active playlist name above the player.
    * Drag and drop implementation details:
        * Details about using `@dnd-kit/core` and `@dnd-kit/sortable` to implement drag and drop functionality in `TrackList.tsx`.
        * Information about the `onReorder` handler in `app/musique/page.tsx` and its role in saving the new order.
        * Share button details:
        * Details about the addition of a share button in `TrackList.tsx` for each track.
    * Lists of new and modified files.
    * TypeScript types, including the addition of `Playlist`, `PlaylistTrack`, and `PlaylistWithTracks` types in `lib/supabaseClient.ts`.
    * Testing details, including tests for:
        * Creating, adding to, removing from, reordering, sharing, loading, and deleting playlists.
        * Persisting the order after reloading.
        * Testing with empty and large playlists.
        * Verifying RLS permissions.
        * Testing reordering during playback.
*   When implementing the drag and drop functionality, use `@dnd-kit/core` and `@dnd-kit/sortable` (or `react-beautiful-dnd` as an alternative).
* When adding social share capabilities, ensure that the correct `ShareContentType` is passed when generating share URLs.
* When adding a button to add tracks to personalized playlists from the main playlist, the description should include:
    * Details about the addition of a button/icon on each element of `TrackList.tsx`.
    * Details about the creation of a `AddToPlaylistDialog.tsx` or a `DropdownMenu`
    * Details about the existing playlists of the user via `playlistService.getUserPlaylists()`.
    * Details about the logic to add the track with `playlistService.addTrackToPlaylist(playlistId, trackId)`.
    * Details about error management, with toasts.
    * Details about the new states, with loading, empty and success states.
* When implementing a system of code repositories with a GitHub-like style:
    * The database schema should include:
        * `repositories` table with columns for `id`, `name`, `description`, `source_type` (`local` or `github`), `github_owner`, `github_repo`, `github_branch`, `storage_path`, `language`, `is_public`, `display_order`, `user_id`, `created_at`, and `updated_at`.
        * `repository_files` table with columns for `id`, `repository_id`, `path`, `content`, `size`, `is_directory`, `last_modified`, and `created_at`.
    * Services to be created:
        * `repositoryService.ts`: CRUD operations for repositories and file management.
        * `githubService.ts`: Integration with the GitHub API.
        * Extend `storageService.ts` for repository file management.
    * UI components to be created:
        * `RepositoryCard.tsx`: Repository card.
        * `RepositoryList.tsx`: List/grid of repositories with filters and search.
        * `FileExplorer.tsx`: GitHub-like file explorer.
        * `CodeViewer.tsx`: Code visualization with syntax highlighting.
        * `MarkdownViewer.tsx`: Enhanced `MarkdownRenderer` for GitHub-like Markdown rendering.
        * `RepositoryDetail.tsx`: Repository detail page integrating `FileExplorer`, `CodeViewer`, and `MarkdownViewer`.
    * Pages to be created/modified:
        * `app/applications/page.tsx`: Repository list page.
        * `app/applications/[id]/page.tsx`: Repository detail page.
    * Supabase migrations:
        * Use the MCP Supabase server for database operations.
        * Create `repositories` and `repository_files` tables with RLS policies using `mcp_supabase_apply_migration`.
        * Create a `repository-files` bucket in Storage.
        * Create indexes for optimized queries.
        * Verify the structure with `mcp_supabase_list_tables` after creation.
        * Use `mcp_supabase_execute_sql` for complex queries if needed.
* When creating a new admin page, you should:
    * Create `app/admin/applications/page.tsx` with a basic structure and `ProtectedRoute`.
    * Create a `RepositoryUploadForm.tsx` component with a toggle between GitHub and Local upload options.
    * Implement the GitHub mode with fields for owner, repo, and branch, including a "Verify" button to test the connection.
    * Implement the Local mode with multi-file upload and drag-and-drop support.
    * Create `RepositoryListAdmin.tsx` for managing existing repositories.
    * Create `RepositoryEditDialog.tsx` to edit repository metadata.
    * Extend `repositoryService.ts` with functions for verifying GitHub repos and uploading local repos.
    * Extend `storageService.ts` with functions for uploading multiple files and creating repository folders.
    * Implement form validation and error handling.
    * Integrate the admin page into the navigation sidebar.
* When uploading a local repository, take `.gitignore` into account and do not upload the files it contains.
* When, from the Application page, a user clicks on a Github repository, they should be redirected to the repository on Github in a new tab.
* When displaying GitHub repository cards, show more information such as the number of forks, the number of stars, etc, using the same icons as GitHub.
* When, from the Application page, a user clicks on a Github repository, they should be redirected to the repository on Github in a new tab.
* When displaying GitHub repository cards, show more information such as the number of forks, the number of stars, etc, using the same icons as GitHub.
* When using `generateStaticParams()` with `output: export`, the function must be on the server side. Move components using it to server components, or use `next/dynamic` with `ssr: false` to load them client-side.

## CODING STANDARDS

*   When importing icons from `lucide-react`, and there is a naming conflict with a type or variable, rename the imported icon using `as`. For example: `import { Video as VideoIcon } from 'lucide-react'`.
*   When implementing a social share feature, create `lib/shareUtils.ts` with all sharing utility functions and `components/ShareButton.tsx` with a dropdown menu and share options. Modify `PhotoViewerModal.tsx`, `TextDetailModal.tsx`, and `AudioPlayer.tsx` to include the `ShareButton`.

## DEBUG

*   When debugging errors, especially those reported as generic messages like "Impossible de modifier le morceau," follow these steps:
    1.  **Examine the relevant code:** Start by inspecting the code where the error is occurring, such as the `TrackEditDialog.tsx` or `PhotoEditModal.tsx` components.
    2.  **Implement detailed logging:** Add `console.log` statements to log data and track the flow of execution. Log details such as function arguments, intermediate values, and any relevant state variables.
    3.  **Inspect network requests:** Use browser developer tools to inspect network requests and responses. Check the request payload and response status to identify any issues with the data being sent or received.
    4.  **Improve error handling:** Enhance error handling in the code to provide more specific error messages. Use try-catch blocks to catch errors and log detailed information about the error, including the error message, error code, and any additional details.
    5.  **Check Supabase permissions (RLS):** Verify that the Supabase Row Level Security (RLS) policies are correctly configured to allow the necessary operations.
    6.  **Validate data formats:** Ensure that the data being sent to the database is in the correct format and meets any constraints imposed by the database schema.
    7.  **Test and verify:** After making changes, thoroughly test the code to ensure that the error has been resolved and that no new issues have been introduced.
*   When debugging the "Impossible de modifier le morceau" error specifically:
    1.  **Add detailed logs** to each step of the `TrackEditDialog.tsx` and `PhotoEditDialog.tsx` components, including:
        *   The data being sent for updates.
        *   The stage at which the error occurs (e.g., updating track information, updating tags).
        *   Full error objects, including error type, constructor, and stringified details.
    2.  **Verify `musicTagService.ts` and `photoTagService.ts`** to ensure errors are correctly handled during the deletion of existing tags and insertion of new tags.
    3.  **If the error is related to missing tables** (e.g., `music_tags`):
        *   The code should continue to function, providing a warning that tags could not be updated due to the missing table.
        *   The tag loading process should also be optional, preventing errors if the table doesn't exist.
    4.  **Ensure proper error messages:** The toast messages should display clear error details, including message, code, status code, hint, and details.
* When a table is missing, the code must continue to function, providing a warning that tags could not be updated due to the missing table. The tag loading process should also be optional, preventing errors if the table doesn't exist.
* When displaying tags on public pages, ensure that each page displays only the tags that are actually used for its content type:
    * Page Photos: only tags from the `photo_tags` table.
    * Page Music: only tags from the `music_tags` table.
    * Page Videos: only tags from the `video_tags` table.
    * Page Texts: only tags from the `text_tags` table.
* When implementing code splitting with `next/dynamic`, always include a `<Skeleton>` component as the `loading` fallback, and set `ssr: false`.
* With `output: 'export'`, Next.js does not allow the use of `headers()` in `next.config.js`. For a static export, headers must be configured at the web server or hosting platform level. See `docs/SECURITY.md` for instructions.
* When encountering `ReferenceError: sessionStorage is not defined`, especially during server-side rendering (SSR), ensure that `sessionStorage` is only accessed in a client-side context. Use a conditional check (`typeof window !== 'undefined'`) before accessing `window.sessionStorage`. If server-side functionality is required, provide a fallback or alternative storage mechanism.
* When implementing enhanced audio player features, follow these guidelines:
    *   **State Management:** Utilize `localStorage` via `lib/audioPlayerStorage.ts` to persist and restore player state (shuffle, repeat, volume, current time). Expire saved data after 30 days.
    *   **Shuffle Mode:** Implement shuffle using the Fisher-Yates algorithm.
    *   **Repeat Mode:** Support 'none', 'one', and 'all' repeat modes.
    *   **Progress Bar Preview:** Display a preview with formatted time on the progress bar during hover.
    *   **Keyboard Controls:** Implement keyboard controls for play/pause (Space), skip forward/backward (ArrowLeft/ArrowRight), volume control (ArrowUp/ArrowDown), and track navigation (Shift + ArrowLeft/ArrowRight).
    *   **Track List Styling:** Indicate the currently playing track in `TrackList.tsx` with visual cues (icon, background color).
    *   **Tooltips:** Use tooltips to explain the functionality of shuffle and repeat buttons.
* When the `LinkedinIcon` component is not defined, it means that the icon was removed during code cleanup. It must be added back by including the relevant SVG code in the `components/ShareButton.tsx` file.
* When using `window.location.origin` in components like `PhotoViewerModal`, `TextDetailModal`, and `AudioPlayer`, ensure to use a conditional check (`typeof window !== 'undefined'`) to prevent errors during server-side rendering or dynamic loading. Example:
    ````
    url={`${typeof window !== 'undefined' ? window.location.origin : ''}/photos#photo-${currentPhoto.id}`}
    ````
* When using `navigator` or `document` APIs (e.g., in `copyToClipboard` function), ensure to use conditional checks to prevent errors during server-side rendering or dynamic loading. Example:
    ````
    if (typeof window === 'undefined' || typeof navigator === 'undefined' || typeof document === 'undefined') {
        return false;
    }
    ````
*   **Database Migrations:** If a "Could not find the table" error occurs, it indicates that the database migration has not been run. To resolve this, execute the SQL migration script in your Supabase project using the SQL Editor. The script is located at `supabase/migrations/YYYYMMDDHHMMSS_create_playlists_system.sql`. After running the migration, verify that the tables are created in the Table Editor.
* When adding social share capabilities, ensure that the correct `ShareContentType` is passed when generating share URLs.
* When the audio player is not producing sound:
    * Ensure that the audio is only played once it is loaded
    * Implement error handling around the audio play function
    * Double check the  `useEffect` hook that manages track changes is properly configured and that it is listening for the correct state changes
* The `AudioPlayer` component should also:
    * Listen for changes to `initialTrackIndex` and update the `currentTrackIndex` state accordingly.
    * Set `isPlaying` to `true` when a new track is loaded, but do so only after the audio has been loaded via `handleCanPlay`.
* To resolve issues with the track list not responding to the "Play" icon, ensure that :
    * The `useEffect` hook that handles playback is listening for both `isPlaying` and `currentTrackIndex`.
    * The audio element's `readyState` is checked before attempting to play to prevent playing before the audio loads.
    * An error handler is implemented for the `audio.play()` call to catch and log any playback errors.
* When implementing a system of code repositories with a GitHub-like style, follow these guidelines:
    * Use the MCP Supabase server for database operations.
    * When creating the database schema, the `repositories` table should include columns
* When implementing a system of code repositories with a GitHub-like style, use the MCP Supabase server for database operations.
    * When creating the database schema, the `repositories` table should include columns for `id`, `name`, `description`, `source_type` (`local` or `github`), `github_owner`, `github_repo`, `github_branch`, `storage_path`, `language`, `is_public`, `display_order`, `user_id`, `created_at`, and `updated_at`.
    * The `repository_files` table should include columns for `id`, `repository_id`, `path`, `content`, `size`, `is_directory`, `last_modified`, and `created_at`.
    * Create services:
        * `repositoryService.ts`: CRUD operations for repositories and file management.
        * `githubService.ts`: Integration with the GitHub API.
        * Extend `storageService.ts` for repository file management.
    * Create UI components:
        * `RepositoryCard.tsx`: Repository card.
        * `RepositoryList.tsx`: List/grid of repositories with filters and search.
        * `FileExplorer.tsx`: GitHub-like file explorer.
        * `CodeViewer.tsx`: Code visualization with syntax highlighting.
        * `MarkdownViewer.tsx`: Enhanced `MarkdownRenderer` for GitHub-like Markdown rendering.
        * `RepositoryDetail.tsx`: Repository detail page integrating `FileExplorer`, `CodeViewer`, and `MarkdownViewer`.
    * Create pages:
        * `app/applications/page.tsx`: Repository list page.
        * `app/applications/[id]/page.tsx`: Repository detail page.
    * Create Supabase migrations using the MCP Supabase server:
        * Create `repositories` and `repository_files` tables with RLS policies using `mcp_supabase_apply_migration`.
        * Create a `repository-files` bucket in Storage.
        * Create indexes for optimized queries.
        * Verify the structure with `mcp_supabase_list_tables` after creation.
        * Use `mcp_supabase_execute_sql` for complex queries if needed.
* When creating a new admin page, you should:
    * Create `app/admin/applications/page.tsx` with a basic structure and `ProtectedRoute`.
    * Create a `RepositoryUploadForm.tsx` component with a toggle between GitHub and Local upload options.
    * Implement the GitHub mode with fields for owner, repo, and branch, including a "Verify" button to test the connection.
    * Implement the Local mode with multi-file upload and drag-and-drop support.
    * Create `RepositoryListAdmin.tsx` for managing existing repositories.
    * Create `RepositoryEditDialog.tsx` to edit repository metadata.
    * Extend `repositoryService.ts` with functions for verifying GitHub repos and uploading local repos.
    * Extend `storageService.ts` with functions for uploading multiple files and creating repository folders.
    * Implement form validation and error handling.
    * Integrate the admin page into the navigation sidebar.
* When uploading a local repository, take `.gitignore` into account and do not upload the files it contains.
* When, from the Application page, a user clicks on a Github repository, they should be redirected to the repository on Github in a new tab.
* When displaying GitHub repository cards, show more information such as the number of forks, the number of stars, etc, using the same icons as GitHub.
* When, from the Application page, a user clicks on a Github repository, they should be redirected to the repository on Github in a new tab.
* When displaying GitHub repository cards, show more information such as the number of forks, the number of stars, etc, using the same icons as GitHub.
* When using `generateStaticParams()` with `output: export`, the function must be on the server side. Move components using it to server components, or use `next/dynamic` with `ssr: false` to load them client-side.