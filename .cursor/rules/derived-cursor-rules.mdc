---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## <headers/>

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

This section covers guidelines for project documentation, especially regarding the `CLAUDE.md` and `AGENTS.md` files.

### Updating `CLAUDE.md` and `AGENTS.md`

The `CLAUDE.md` and `AGENTS.md` files must be kept up-to-date to reflect the current state of the codebase. The update process involves:

1.  **Reading Existing Files:** Always start by reading the current versions of `@CLAUDE.md` and `@AGENTS.md`.
2.  **Project Analysis:** Analyze the project structure, configuration, key components, contexts, services, and library configurations. Key files to inspect include:
    *   `package.json`
    *   `tsconfig.json`
    *   `next.config.js`
    *   `tailwind.config.ts`
    *   `app/layout.tsx`
    *   `app/*/page.tsx`
    *   `components/AppLayout.tsx`
    *   `contexts/*.tsx`
    *   `services/*.tsx`
    *   `components/Sidebar.tsx`
    *   `components/Topbar.tsx`
    *   `lib/*.ts`
3.  **Change Identification:** Compare the current project state with the documentation in `CLAUDE.md` and `AGENTS.md` to identify discrepancies. Look for:
    *   New contexts or services.
    *   New routes or pages.
    *   New important dependencies.
    *   Changes in architecture.
    *   New patterns or conventions.
    *   Modifications in provider structure.
4.  **`CLAUDE.md` Content:**
    *   **Must Include:**
        *   Project overview.
        *   Development commands.
        *   High-level architecture (requiring the reading of multiple files).
        *   Route structure.
        *   Layout system.
        *   Theme and context systems.
        *   Backend integration (e.g., Supabase).
        *   Component library.
        *   Development patterns.
    *   **Must Not Include:**
        *   Obvious instructions.
        *   Generic development practices.
        *   Easily discoverable information.
5.  **`AGENTS.md` Content:**
    *   **Must Include:**
        *   Naming conventions.
        *   File structure (templates).
        *   Import order.
        *   Patterns to follow (Client vs Server, state management, error handling).
        *   Specific workflows (adding pages, service, component).
        *   Styling guidelines.
        *   Project-specific points of attention.
        *   Language conventions.
    *   **Template Format:** Always provide concrete code examples showing the expected file structure.
6.  **Validation:** Ensure consistency between the two files, up-to-date information, correct code examples, accurate file paths, and a provider hierarchy in `CLAUDE.md` that matches the actual code. Also ensure new services/contexts are documented.
7. **Process:**
    * List the identified changes as bullet points.
    * Update `CLAUDE.md` with the necessary modifications.
    * Update `AGENTS.md` with the necessary modifications.
    * Summarize the changes made in each file.
8. **Important Instructions:**
    * Be exhaustive in the analysis.
    * Verify ALL contexts in `contexts/`.
    * Verify ALL services in `services/`.
    * List all current routes.
    * Verify the actual structure of providers in `app/layout.tsx`.
    * Maintain the existing format and structure of the files.
    * Do not invent information - always check the code source.

## TECH STACK

## WORKFLOW & RELEASE RULES

*   When creating a pull request, analyze recent file changes to understand the modifications.
*   Utilize tools like `read_file`, `codebase_search`, and `grep` to identify changes.
*   Search for specific keywords or patterns related to the changes (e.g., "admin/(photos|music|videos|texts)" in `components/Sidebar.tsx`).
*   Search for "CHANGELOG" to track changes.
*   Based on the analysis, generate a detailed pull request description including:
    *   A summary of the changes.
    *   A list of the main changes.
    *   The files modified.
    *   Technical details.
    *   A checklist of tests performed.
    *   Screenshots (if applicable).
    *   Links to related issues.
    *   The type of change (e.g., feature).
    *   The impact of the change.
    *   Whether there are any breaking changes.
* When implementing new features that require database changes, such as adding a tagging system, the pull request description must include:
    * Database schema changes, including new tables, columns, and relationships.
    * RLS (Row Level Security) configurations for new tables.
    * Migration scripts (SQL) to apply the database changes.
    * Suggested default tags for the new feature, where applicable.
* When creating a pull request for a unified tagging system, the description should include:
    * A summary of the addition of a unified tagging system for classifying and organizing content (photos, videos, music, texts).
    * Details about the shared tags across all media types and the centralized management interface.
    * Information about the database schema:
        * `tags` table with name, slug (auto-generated), and customizable color.
        * Many-to-many relationship tables: `photo_tags`, `video_tags`, `music_tags`, and `text_tags`.
        * Indexes for optimized search queries.
        * CASCADE constraints for automatic relationship deletion.
    * Backend services details:
        * `tagService.ts`: CRUD operations for tags and management of relationships with texts.
        * `photoTagService.ts`, `videoTagService.ts`, `musicTagService.ts`: management of tag relationships for photos, videos, and music respectively.
        * `createPhotoWithTags`, `createVideoWithTags`, `createTrackWithTags` methods in respective services.
        * `getAllPhotosWithTags`, `getAllVideosWithTags`, `getAllTracksWithTags` methods for retrieving media with their tags.
    * Admin interface details:
        * `TagManager`: interface for tag management (creation, modification, deletion, color selection, Zod validation, grid display with colored badges).
        * Integration in admin pages: `/admin/photos`, `/admin/videos`, `/admin/music`, and `/admin/texts`.
    * UI components details:
        * `TagBadge`: reusable component for displaying tags with `default`, `outline`, and `secondary` variants, customizable colors, and click/delete support.
        * Integration in upload forms: `PhotoUploadForm`, `VideoUploadForm`, `MusicUploadForm`, and `TextUploadForm`.
    * Public display details:
        * Tags displayed on content cards (photos, videos, texts) with colored badges and consistent styling supporting light/dark themes.
    * Lists of new and modified files.
    * TypeScript types, including `Tag`, `PhotoWithTags`, `VideoWithTags`, and `MusicTrackWithTags`.
    * Migration details, including the creation of relationship tables with primary key constraints, foreign key constraints with CASCADE, indexes, and documentation comments.
    * Recommended tests (create, modify, delete tags; upload media with tags; upload media with tags; verify tag display on public pages; verify color consistency in light/dark mode).
    * Technical notes (shared tags, auto-generated slugs, hexadecimal color storage, automatic cascading deletion, error management with `{ data, error }` pattern, and Zod validation).
*   **CI/CD with GitHub Actions:**
    *   Set up CI/CD workflows using GitHub Actions for automated linting, type checking, building, and deployment.
    *   Create `.github/workflows/ci.yml` for continuous integration:
        ```yaml
        name: CI

        on:
          push:
            branches: [ main, develop ]
          pull_request:
            branches: [ main, develop ]

        jobs:
          lint-and-typecheck:
            name: Lint & Type Check
            runs-on: ubuntu-latest

            steps:
              - name: Checkout code
                uses: actions/checkout@v4

              - name: Setup Node.js
                uses: actions/setup-node@v4
                with:
                  node-version: '20'
                  cache: 'npm'

              - name: Install dependencies
                run: npm ci

              - name: Run ESLint
                run: npm run lint

              - name: Run TypeScript type check
                run: npm run type check

          build:
            name: Build
            runs-on: ubuntu-latest
            needs: lint-and-typecheck

            steps:
              - name: Checkout code
                uses: actions/checkout@v4

              - name: Setup Node.js
                uses: actions/setup-node@v4
                with:
                  node-version: '20'
                  cache: 'npm'

              - name: Install dependencies
                run: npm ci

              - name: Build project
                run: npm run build
                env:
                  # Variables nécessaires pour le build (même si vides, pour éviter les erreurs)
                  NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL || '' }}
                  NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY || '' }}

              - name: Upload build artifacts
                uses: actions/upload-artifact@v4
                with:
                  name: build-output
                  path: out/
                  retention-days: 7
        ```
    *   Create `.github/workflows/deploy.yml` for automated deployment (optional):
        ```yaml
        name: Deploy

        on:
          push:
            branches: [ main ]

        jobs:
          deploy:
            name: Deploy to Production
            runs-on: ubuntu-latest
            if: github.ref == 'refs/heads/main'

            steps:
              - name: Checkout code
                uses: actions/checkout@v4

              - name: Setup Node.js
                uses: actions/setup-node@v4
                with:
                  node-version: '20'
                  cache: 'npm'

              - name: Install dependencies
                run: npm ci

              - name: Build project
                run: npm run build
                env:
                  NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
                  NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}

              # Option 1: Déploiement sur GitHub Pages
              - name: Deploy to GitHub Pages
                uses: peaceiris/actions-gh-pages@v3
                if: github.ref == 'refs/heads/main'
                with:
                  github_token: ${{ secrets.GITHUB_TOKEN }}
                  publish_dir: ./out

              # Option 2: Déploiement sur Vercel (décommentez si vous utilisez Vercel)
              # - name: Deploy to Vercel
              #   uses: amondnet/vercel-action@v25
              #   with:
              #     vercel-token: ${{ secrets.VERCEL_TOKEN }}
              #     vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
              #     vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
              #     vercel-args: '--prod'
        ```
    *   Configure GitHub secrets in the repository settings (Settings → Secrets and variables → Actions):
        *   `NEXT_PUBLIC_SUPABASE_URL`: Supabase URL.
        *   `NEXT_PUBLIC_SUPABASE_ANON_KEY`: Supabase anonymous key.
        *   (Optional) `GITHUB_TOKEN`: Automatically generated.
        *   (Optional) `VERCEL_TOKEN`, `VERCEL_ORG_ID`, `VERCEL_PROJECT_ID`: If using Vercel.
    *   If the main branch is named `master` instead of `main`, update the `.yml` files accordingly.
*   When discussing an idea with AI and asking for a PRD:
    *   For simple projects, use the `example_prd.txt` template.
    *   For complex systems, use the `example_prd_rpg.txt` template (for dependency-aware task graphs). Save the PRD to `.taskmaster/docs/prd.txt`.
    *   After the PRD is created, parse it to generate initial tasks using: `task-master parse-prd .taskmaster/docs/prd.txt`. Then, analyze the complexity of these tasks with `task-master analyze-complexity --research` and expand the tasks into sub-tasks with `task-master expand --all --research`. Finally, see the next task to do with `task-master next`.

## CODING STANDARDS

## DEBUG

*   When debugging errors, especially those reported as generic messages like "Impossible de modifier le morceau," follow these steps:
    1.  **Examine the relevant code:** Start by inspecting the code where the error is occurring, such as the `TrackEditDialog.tsx` or `PhotoEditModal.tsx` components.
    2.  **Implement detailed logging:** Add `console.log` statements to log data and track the flow of execution. Log details such as function arguments, intermediate values, and any relevant state variables.
    3.  **Inspect network requests:** Use browser developer tools to inspect network requests and responses. Check the request payload and response status to identify any issues with the data being sent or received.
    4.  **Improve error handling:** Enhance error handling in the code to provide more specific error messages. Use try-catch blocks to catch errors and log detailed information about the error, including the error message, error code, and any additional details.
    5.  **Check Supabase permissions (RLS):** Verify that the Supabase Row Level Security (RLS) policies are correctly configured to allow the necessary operations.
    6.  **Validate data formats:** Ensure that the data being sent to the database is in the correct format and meets any constraints imposed by the database schema.
    7.  **Test and verify:** After making changes, thoroughly test the code to ensure that the error has been resolved and that no new issues have been introduced.
*   When debugging the "Impossible de modifier le morceau" error specifically:
    1.  **Add detailed logs** to each step of the `TrackEditDialog.tsx` and `PhotoEditDialog.tsx` components, including:
        *   The data being sent for updates.
        *   The stage at which the error occurs (e.g., updating track information, updating tags).
        *   Full error objects, including error type, constructor, and stringified details.
    2.  **Verify `musicTagService.ts` and `photoTagService.ts`** to ensure errors are correctly handled during the deletion of existing tags and insertion of new tags.
    3.  **If the error is related to missing tables** (e.g., `music_tags`):
        *   The code should continue to function, providing a warning that tags could not be updated due to the missing table.
        *   The tag loading process should also be optional, preventing errors if the table doesn't exist.
    4.  **Ensure proper error messages:** The toast messages should display clear error details, including message, code, status code, hint, and details.
* When a table is missing, the code must continue to function, providing a warning that tags could not be updated due to the missing table. The tag loading process should also be optional, preventing errors if the table doesn't exist.
* When displaying tags on public pages, ensure that each page displays only the tags that are actually used for its content type:
    * Page Photos: only tags from the `photo_tags` table.
    * Page Music: only tags from the `music_tags` table.
    * Page Videos: only tags from the `video_tags` table.
    * Page Texts: only tags from the `text_tags` table.