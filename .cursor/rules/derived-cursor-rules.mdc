---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## <headers/>

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

This section covers guidelines for project documentation, especially regarding the `CLAUDE.md` and `AGENTS.md` files.

### Updating `CLAUDE.md` and `AGENTS.md`

The `CLAUDE.md` and `AGENTS.md` files must be kept up-to-date to reflect the current state of the codebase. The update process involves:

1.  **Reading Existing Files:** Always start by reading the current versions of `@CLAUDE.md` and `@AGENTS.md`.
2.  **Project Analysis:** Analyze the project structure, configuration, key components, contexts, services, and library configurations. Key files to inspect include:
    *   `package.json`
    *   `tsconfig.json`
    *   `next.config.js`
    *   `tailwind.config.ts`
    *   `app/layout.tsx`
    *   `app/*/page.tsx`
    *   `components/AppLayout.tsx`
    *   `contexts/*.tsx`
    *   `services/*.ts`
    *   `components/Sidebar.tsx`
    *   `components/Topbar.tsx`
    *   `lib/*.ts`
3.  **Change Identification:** Compare the current project state with the documentation in `CLAUDE.md` and `AGENTS.md` to identify discrepancies. Look for:
    *   New contexts or services.
    *   New routes or pages.
    *   New important dependencies.
    *   Changes in architecture.
    *   New patterns or conventions.
    *   Modifications in provider structure.
4.  **`CLAUDE.md` Content:**
    *   **Must Include:**
        *   Project overview.
        *   Development commands.
        *   High-level architecture (requiring the reading of multiple files).
        *   Route structure.
        *   Layout system.
        *   Theme and context systems.
        *   Backend integration (e.g., Supabase).
        *   Component library.
        *   Development patterns.
    *   **Must Not Include:**
        *   Obvious instructions.
        *   Generic development practices.
        *   Easily discoverable information.
5.  **`AGENTS.md` Content:**
    *   **Must Include:**
        *   Naming conventions.
        *   File structure (templates).
        *   Import order.
        *   Patterns to follow (Client vs Server, state management, error handling).
        *   Specific workflows (adding pages, service, component).
        *   Styling guidelines.
        *   Project-specific points of attention.
        *   Language conventions.
    *   **Template Format:** Always provide concrete code examples showing the expected file structure.
6.  **Validation:** Ensure consistency between the two files, up-to-date information, correct code examples, accurate file paths, and a provider hierarchy in `CLAUDE.md` that matches the actual code. Also ensure new services/contexts are documented.
7. **Process:**
    * List the identified changes as bullet points.
    * Update `CLAUDE.md` with the necessary modifications.
    * Update `AGENTS.md` with the necessary modifications.
    * Summarize the changes made in each file.
8. **Important Instructions:**
    * Be exhaustive in the analysis.
    * Verify ALL contexts in `contexts/`.
    * Verify ALL services in `services/`.
    * List all current routes.
    * Verify the actual structure of providers in `app/layout.tsx`.
    * Maintain the existing format and structure of the files.
    * Do not invent information - always check the code source.

## TECH STACK

## WORKFLOW & RELEASE RULES

*   When creating a pull request, analyze recent file changes to understand the modifications.
*   Utilize tools like `read_file`, `codebase_search`, and `grep` to identify changes.
*   Search for specific keywords or patterns related to the changes (e.g., "admin/(photos|music|videos|texts)" in `components/Sidebar.tsx`).
*   Search for "CHANGELOG" to track changes.
*   Based on the analysis, generate a detailed pull request description including:
    *   A summary of the changes.
    *   A list of the main changes.
    *   The files modified.
    *   Technical details.
    *   A checklist of tests performed.
    *   Screenshots (if applicable).
    *   Links to related issues.
    *   The type of change (e.g., feature).
    *   The impact of the change.
    *   Whether there are any breaking changes.
* When implementing new features that require database changes, such as adding a tagging system, the pull request description must include:
    * Database schema changes, including new tables, columns, and relationships.
    * RLS (Row Level Security) configurations for new tables.
    * Migration scripts (SQL) to apply the database changes.
    * Suggested default tags for the new feature, where applicable.
* When creating a pull request for a unified tagging system, the description should include:
    * A summary of the addition of a unified tagging system for classifying and organizing content (photos, videos, music, texts).
    * Details about the shared tags across all media types and the centralized management interface.
    * Information about the database schema:
        * `tags` table with name, slug (auto-generated), and customizable color.
        * Many-to-many relationship tables: `photo_tags`, `video_tags`, `music_tags`, and `text_tags`.
        * Indexes for optimized search queries.
        * CASCADE constraints for automatic relationship deletion.
    * Backend services details:
        * `tagService.ts`: CRUD operations for tags and management of relationships with texts.
        * `photoTagService.ts`, `videoTagService.ts`, `musicTagService.ts`: management of tag relationships for photos, videos, and music respectively.
        * `createPhotoWithTags`, `createVideoWithTags`, `createTrackWithTags` methods in respective services.
        * `getAllPhotosWithTags`, `getAllVideosWithTags`, `getAllTracksWithTags` methods for retrieving media with their tags.
    * Admin interface details:
        * `TagManager`: interface for tag management (creation, modification, deletion, color selection, Zod validation, grid display with colored badges).
        * Integration in admin pages: `/admin/photos`, `/admin/videos`, `/admin/music`, and `/admin/texts`.
    * UI components details:
        * `TagBadge`: reusable component for displaying tags with `default`, `outline`, and `secondary` variants, customizable colors, and click/delete support.
        * Integration in upload forms: `PhotoUploadForm`, `VideoUploadForm`, `MusicUploadForm`, and `TextUploadForm`.
    * Public display details:
        * Tags displayed on content cards (photos, videos, texts) with colored badges and consistent styling supporting light/dark themes.
    * Lists of new and modified files.
    * TypeScript types, including `Tag`, `PhotoWithTags`, `VideoWithTags`, and `MusicTrackWithTags`.
    * Migration details, including the creation of relationship tables with primary key constraints, foreign key constraints with CASCADE, indexes, and documentation comments.
    * Recommended tests (create, modify, delete tags; upload media with tags; verify tag display on public pages; verify color consistency in light/dark mode).
    * Technical notes (shared tags, auto-generated slugs, hexadecimal color storage, automatic cascading deletion, error management with `{ data, error }` pattern, and Zod validation).
*   **CI/CD with GitHub Actions:**
    *   Set up CI/CD workflows using GitHub Actions for automated linting, type checking, building, and deployment.
    *   Create `.github/workflows/ci.yml` for continuous integration:
        ```yaml
        name: CI

        on:
          push:
            branches: [ main, develop ]
          pull_request:
            branches: [ main, develop ]

        jobs:
          lint-and-typecheck:
            name: Lint & Type Check
            runs-on: ubuntu-latest

            steps:
              - name: Checkout code
                uses: actions/checkout@v4

              - name: Setup Node.js
                uses: actions/setup-node@v4
                with:
                  node-version: '20'
                  cache: 'npm'

              - name: Install dependencies
                run: npm ci

              - name: Run ESLint
                run: npm run lint

              - name: Run TypeScript type check
                run: npm run type check

          build:
            name: Build
            runs-on: ubuntu-latest
            needs: lint-and-typecheck

            steps:
              - name: Checkout code
                uses: actions/checkout@v4

              - name: Setup Node.js
                uses: actions/setup-node@v4
                with:
                  node-version: '20'
                  cache: 'npm'

              - name: Install dependencies
                run: npm ci

              - name: Build project
                run: npm run build
                env:
                  # Variables n√©cessaires pour le build (m√™me si vides, pour √©viter les erreurs)
                  NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL || '' }}
                  NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY || '' }}

              - name: Upload build artifacts
                uses: actions/upload-artifact@v4
                with:
                  name: build-output
                  path: out/
                  retention-days: 7
        ```
    *   Create `.github/workflows/deploy.yml` for automated deployment (optional):
        ```yaml
        name: Deploy

        on:
          push:
            branches: [ main ]

        jobs:
          deploy:
            name: Deploy to Production
            runs-on: ubuntu-latest
            if: github.ref == 'refs/heads/main'

            steps:
              - name: Checkout code
                uses: actions/checkout@v4

              - name: Setup Node.js
                uses: actions/setup-node@v4
                with:
                  node-version: '20'
                  cache: 'npm'

              - name: Install dependencies
                run: npm ci

              - name: Build project
                run: npm run build
                env:
                  NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
                  NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}

              # Option 1: D√©ploiement sur GitHub Pages
              - name: Deploy to GitHub Pages
                uses: peaceiris/actions-gh-pages@v3
                if: github.ref == 'refs/heads/main'
                with:
                  github_token: ${{ secrets.GITHUB_TOKEN }}
                  publish_dir: ./out

              # Option 2: D√©ploiement sur Vercel (d√©commentez si vous utilisez Vercel)
              # - name: Deploy to Vercel
              #   uses: amondnet/vercel-action@v25
              #   with:
              #     vercel-token: ${{ secrets.VERCEL_TOKEN }}
              #     vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
              #     vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
              #     vercel-args: '--prod'
        ```
    *   Configure GitHub secrets in the repository settings (Settings ‚Üí Secrets and variables ‚Üí Actions):
        *   `NEXT_PUBLIC_SUPABASE_URL`: Supabase URL.
        *   `NEXT_PUBLIC_SUPABASE_ANON_KEY`: Supabase anonymous key.
        *   (Optional) `GITHUB_TOKEN`: Automatically generated.
        *   (Optional) `VERCEL_TOKEN`, `VERCEL_ORG_ID`, `VERCEL_PROJECT_ID`: If using Vercel.
    *   If the main branch is named `master` instead of `main`, update the `.yml` files accordingly.
    *   Create `.github/pull_request_template.md` for a reusable pull request template. This template should include sections for:
        *   Description of changes
        *   Type of change (bug fix, new feature, CI/CD, etc.)
        *   Checklist of verifications
        *   Sections for tests, screenshots, and links.
        Example:
        ```md
        ## Description

        <!-- D√©crivez bri√®vement les changements apport√©s dans cette PR -->

        ## Type de changement

        <!-- Cochez les cases applicables avec un 'x' -->

        - [ ] üêõ Bug fix (correction qui ne casse pas les fonctionnalit√©s existantes)
        - [ ] ‚ú® Nouvelle fonctionnalit√© (ajout qui ne casse pas les fonctionnalit√©s existantes)
        - [ ] üí• Breaking change (fix ou fonctionnalit√© qui casse les fonctionnalit√©s existantes)
        - [ ] üìö Documentation (changements dans la documentation uniquement)
        - [ ] üîß Configuration CI/CD (changements dans les workflows GitHub Actions)
        - [ ] üé® Style (formatage, point-virgule manquant, etc., pas de changement de code)
        - [ ] ‚ôªÔ∏è Refactoring (refactoring du code sans changement de fonctionnalit√©)
        - [ ] ‚ö° Performance (am√©lioration des performances)
        - [ ] ‚úÖ Tests (ajout ou modification de tests)
        - [ ] üî® Build (changements dans le syst√®me de build ou d√©pendances)

        ## Checklist

        <!-- V√©rifiez que vous avez compl√©t√© les √©tapes suivantes -->

        - [ ] Mon code suit les conventions de style du projet (voir `AGENTS.md`)
        - [ ] J'ai effectu√© une auto-revue de mon code
        - [ ] J'ai comment√© mon code, particuli√®rement dans les parties complexes
        - [ ] J'ai mis √† jour la documentation si n√©cessaire
        - [ ] Mes changements ne g√©n√®rent pas de nouveaux warnings
        - [ ] J'ai ajout√© des tests qui prouvent que ma correction est efficace ou que ma fonctionnalit√© fonctionne
        - [ ] Les tests unitaires nouveaux et existants passent localement avec mes changements
        - [ ] Les v√©rifications CI passent (lint, typecheck, build)

        ## Tests

        <!-- D√©crivez les tests que vous avez effectu√©s pour v√©rifier vos changements -->

        - [ ] Tests manuels effectu√©s
        - [ ] Tests automatis√©s ajout√©s/modifi√©s
        - [ ] V√©rification du build local r√©ussie
        - [ ] V√©rification du linting r√©ussie
        - [ ] V√©rification du type checking r√©ussie

        ## Captures d'√©cran / D√©monstration

        <!-- Si applicable, ajoutez des captures d'√©cran ou une d√©monstration de vos changements -->

        ## Informations suppl√©mentaires

        <!-- Ajoutez toute autre information pertinente pour les reviewers -->

        ## Liens

        <!-- Si applicable, ajoutez des liens vers des issues, discussions, ou documentation -->

        - Closes #<!-- num√©ro d'issue -->
        - Relates to #<!-- num√©ro d'issue -->
        ```
    *  For CI/CD pull requests, use a pre-filled description template located at `.github/PULL_REQUEST_CI.md`. Example:
        ```md
        ## üöÄ Ajout de la configuration CI/CD

        ### Description

        Cette PR ajoute la configuration CI/CD compl√®te pour le projet avec GitHub Actions.

        ### Changements apport√©s

        - ‚úÖ **Workflow CI** (`.github/workflows/ci.yml`)
            - V√©rification automatique du linting avec ESLint
            - V√©rification des types TypeScript
            - Build automatique du projet Next.js
            - Upload des artifacts de build pour inspection

        - ‚úÖ **Workflow de d√©ploiement** (`.github/workflows/deploy.yml`)
            - D√©ploiement automatique sur GitHub Pages lors des push sur `main`
            - Support optionnel pour Vercel (comment√©, pr√™t √† activer)

        ### Type de changement

        - [x] üîß Configuration CI/CD

        ### Checklist

        - [x] Les workflows sont correctement configur√©s
        - [x] Les secrets GitHub doivent √™tre configur√©s manuellement (voir instructions ci-dessous)
        - [x] La documentation est incluse dans cette PR

        ### Configuration requise

        ‚ö†Ô∏è **Action requise avant merge** : Configurer les secrets GitHub suivants dans Settings ‚Üí Secrets and variables ‚Üí Actions :

        - `NEXT_PUBLIC_SUPABASE_URL`
        - `NEXT_PUBLIC_SUPABASE_ANON_KEY`

        ### Tests

        - [x] Les workflows ont √©t√© test√©s localement (syntaxe YAML valid√©e)
        - [x] La configuration est compatible avec Next.js 13 et l'export statique

        ### Informations suppl√©mentaires

        - Les workflows se d√©clencheront automatiquement sur les branches `main` et `develop`
        - Le workflow de d√©ploiement ne s'ex√©cute que sur `main`
        - Les artifacts de build sont conserv√©s pendant 7 jours
        - Le cache npm est activ√© pour acc√©l√©rer les builds

        ### Prochaines √©tapes apr√®s merge

        1. Configurer les secrets GitHub (voir section "Configuration requise")
        2. Activer GitHub Pages dans les param√®tres du d√©p√¥t (si utilisation de GitHub Pages)
        3. Faire un test push sur `main` pour v√©rifier le fonctionnement
        ```

## CODING STANDARDS

## DEBUG

*   When debugging errors, especially those reported as generic messages like "Impossible de modifier le morceau," follow these steps:
    1.  **Examine the relevant code:** Start by inspecting the code where the error is occurring, such as the `TrackEditDialog.tsx` or `PhotoEditModal.tsx` components.
    2.  **Implement detailed logging:** Add `console.log` statements to log data and track the flow of execution. Log details such as function arguments, intermediate values, and any relevant state variables.
    3.  **Inspect network requests:** Use browser developer tools to inspect network requests and responses. Check the request payload and response status to identify any issues with the data being sent or received.
    4.  **Improve error handling:** Enhance error handling in the code to provide more specific error messages. Use try-catch blocks to catch errors and log detailed information about the error, including the error message, error code, and any additional details.
    5.  **Check Supabase permissions (RLS):** Verify that the Supabase Row Level Security (RLS) policies are correctly configured to allow the necessary operations.
    6.  **Validate data formats:** Ensure that the data being sent to the database is in the correct format and meets any constraints imposed by the database schema.
    7.  **Test and verify:** After making changes, thoroughly test the code to ensure that the error has been resolved and that no new issues have been introduced.
*   When debugging the "Impossible de modifier le morceau" error specifically:
    1.  **Add detailed logs** to each step of the `TrackEditDialog.tsx` and `PhotoEditDialog.tsx` components, including:
        *   The data being sent for updates.
        *   The stage at which the error occurs (e.g., updating track information, updating tags).
        *   Full error objects, including error type, constructor, and stringified details.
    2.  **Verify `musicTagService.ts` and `photoTagService.ts`** to ensure errors are correctly handled during the deletion of existing tags and insertion of new tags.
    3.  **If the error is related to missing tables** (e.g., `music_tags`):
        *   The code should continue to function, providing a warning that tags could not be updated due to the missing table.
        *   The tag loading process should also be optional, preventing errors if the table doesn't exist.
    4.  **Ensure proper error messages:** The toast messages should display clear error details, including message, code, status code, hint, and details.
* When a table is missing, the code must continue to function, providing a warning that tags could not be updated due to the missing table. The tag loading process should also be optional, preventing errors if the table doesn't exist.